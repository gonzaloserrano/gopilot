# CSRF (Cross-Site Request Forgery) Protection

## What is CSRF?

CSRF forces authenticated users to execute unwanted actions. Attackers trick users to click malicious links that perform state-changing requests.

## Attack Example

```
User is logged into https://bank.com
Attacker sends: https://bank.com/transfer?to=attacker&amount=10000
User clicks link â†’ Money transferred!
```

## The Solution

Use CSRF tokens: server-generated nonces validated on state-changing requests.

## Using Gorilla CSRF

```go
import (
    "github.com/gorilla/csrf"
    "github.com/gorilla/mux"
)

func main() {
    r := mux.NewRouter()
    r.HandleFunc("/signup", ShowForm)
    r.HandleFunc("/signup/post", HandleSubmit)

    // Wrap router with CSRF protection
    csrfKey := []byte("32-byte-long-auth-key-goes-here!")
    handler := csrf.Protect(csrfKey)(r)

    // Development: csrf.Secure(false) to work over HTTP
    http.ListenAndServe(":8000", handler)
}
```

## Form Template

```go
func ShowForm(w http.ResponseWriter, r *http.Request) {
    // Inject CSRF token into template
    data := map[string]interface{}{
        csrf.TemplateTag: csrf.TemplateField(r),
    }

    // Template uses {{ .csrfField }}
    tmpl.ExecuteTemplate(w, "form.html", data)
}
```

HTML template:
```html
<form method="POST" action="/signup/post">
    {{ .csrfField }}
    <input type="text" name="email">
    <button type="submit">Sign Up</button>
</form>
```

## JSON APIs

```go
func ShowForm(w http.ResponseWriter, r *http.Request) {
    // Set token in header
    w.Header().Set("X-CSRF-Token", csrf.Token(r))

    // Send as JSON
    json.NewEncoder(w).Encode(map[string]string{
        "csrf_token": csrf.Token(r),
    })
}
```

Client includes token in request header:
```javascript
fetch('/api/endpoint', {
    method: 'POST',
    headers: {
        'X-CSRF-Token': csrfToken
    },
    body: JSON.stringify(data)
})
```

## Token Requirements

CSRF tokens must be:
1. **Unique per user session**
2. **Large random value** (128+ bits)
3. **Generated by crypto/rand**
4. **Validated on all state-changing requests** (POST, PUT, DELETE)

## Custom Implementation

If not using gorilla/csrf:

```go
import "crypto/rand"
import "encoding/base64"

// Generate token
func GenerateCSRFToken() (string, error) {
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    return base64.URLEncoding.EncodeToString(bytes), nil
}

// Store in session
func SetCSRFToken(w http.ResponseWriter, r *http.Request) (string, error) {
    token, err := GenerateCSRFToken()
    if err != nil {
        return "", err
    }

    session, _ := store.Get(r, "session")
    session.Values["csrf_token"] = token
    session.Save(r, w)

    return token, nil
}

// Validate token
func ValidateCSRFToken(r *http.Request) error {
    session, _ := store.Get(r, "session")
    storedToken, ok := session.Values["csrf_token"].(string)
    if !ok {
        return errors.New("no CSRF token in session")
    }

    submittedToken := r.FormValue("csrf_token")
    if submittedToken == "" {
        submittedToken = r.Header.Get("X-CSRF-Token")
    }

    if storedToken != submittedToken {
        return errors.New("CSRF token mismatch")
    }

    return nil
}
```

## Protection Patterns

### Double Submit Cookie

```go
func SetDoubleSubmitCookie(w http.ResponseWriter) (string, error) {
    token, err := GenerateCSRFToken()
    if err != nil {
        return "", err
    }

    // Set in cookie
    http.SetCookie(w, &http.Cookie{
        Name:     "csrf_token",
        Value:    token,
        HttpOnly: false,  // JavaScript needs to read it
        Secure:   true,
        SameSite: http.SameSiteStrictMode,
    })

    return token, nil
}
```

### Synchronizer Token Pattern

Store token in session, validate on each request.

## SameSite Cookie Attribute

Modern browsers provide automatic CSRF protection:

```go
cookie := http.Cookie{
    SameSite: http.SameSiteStrictMode,  // Strongest protection
    // or
    SameSite: http.SameSiteLaxMode,     // Allows GET from external sites
}
```

**Note:** Use SameSite + CSRF tokens for defense in depth.

## Best Practices

1. **Use established libraries** (gorilla/csrf)
2. **All state-changing requests** (POST, PUT, DELETE, PATCH)
3. **Don't validate on GET** (GET should be idempotent)
4. **Per-session tokens** (not per-request unless critical)
5. **Check Origin header** (additional validation)
6. **SameSite=Strict cookies** (automatic protection)
7. **HTTPS only** (protect tokens in transit)

## Origin/Referer Validation

Additional protection:

```go
func ValidateOrigin(r *http.Request) error {
    origin := r.Header.Get("Origin")
    if origin == "" {
        origin = r.Header.Get("Referer")
    }

    expectedOrigin := "https://yourdomain.com"
    if !strings.HasPrefix(origin, expectedOrigin) {
        return errors.New("invalid origin")
    }

    return nil
}
```
